{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport { checkRendering, warning, createDocumentationMessageGenerator, isEqual, noop } from \"../../lib/utils/index.js\";\nvar withUsage = createDocumentationMessageGenerator({\n  name: 'breadcrumb',\n  connector: true\n});\nvar connectBreadcrumb = function connectBreadcrumb(renderFn) {\n  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  checkRendering(renderFn, withUsage());\n  var connectorState = {};\n  return function (widgetParams) {\n    var _ref = widgetParams || {},\n      attributes = _ref.attributes,\n      _ref$separator = _ref.separator,\n      separator = _ref$separator === void 0 ? ' > ' : _ref$separator,\n      _ref$rootPath = _ref.rootPath,\n      rootPath = _ref$rootPath === void 0 ? null : _ref$rootPath,\n      _ref$transformItems = _ref.transformItems,\n      transformItems = _ref$transformItems === void 0 ? function (items) {\n        return items;\n      } : _ref$transformItems;\n    if (!attributes || !Array.isArray(attributes) || attributes.length === 0) {\n      throw new Error(withUsage('The `attributes` option expects an array of strings.'));\n    }\n    var _attributes = _slicedToArray(attributes, 1),\n      hierarchicalFacetName = _attributes[0];\n    function getRefinedState(state, facetValue) {\n      if (!facetValue) {\n        var breadcrumb = state.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);\n        if (breadcrumb.length === 0) {\n          return state;\n        } else {\n          return state.resetPage().toggleFacetRefinement(hierarchicalFacetName, breadcrumb[0]);\n        }\n      }\n      return state.resetPage().toggleFacetRefinement(hierarchicalFacetName, facetValue);\n    }\n    return {\n      $$type: 'ais.breadcrumb',\n      init: function init(initOptions) {\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(initOptions)), {}, {\n          instantSearchInstance: initOptions.instantSearchInstance\n        }), true);\n      },\n      render: function render(renderOptions) {\n        renderFn(_objectSpread(_objectSpread({}, this.getWidgetRenderState(renderOptions)), {}, {\n          instantSearchInstance: renderOptions.instantSearchInstance\n        }), false);\n      },\n      dispose: function dispose() {\n        unmountFn();\n      },\n      getRenderState: function getRenderState(renderState, renderOptions) {\n        return _objectSpread(_objectSpread({}, renderState), {}, {\n          breadcrumb: _objectSpread(_objectSpread({}, renderState.breadcrumb), {}, _defineProperty({}, hierarchicalFacetName, this.getWidgetRenderState(renderOptions)))\n        });\n      },\n      getWidgetRenderState: function getWidgetRenderState(_ref2) {\n        var _this = this;\n        var helper = _ref2.helper,\n          createURL = _ref2.createURL,\n          results = _ref2.results,\n          state = _ref2.state;\n        function getItems() {\n          // The hierarchicalFacets condition is required for flavors\n          // that render immediately with empty results, without relying\n          // on init() (like React InstantSearch).\n          if (!results || state.hierarchicalFacets.length === 0) {\n            return [];\n          }\n          var _state$hierarchicalFa = _slicedToArray(state.hierarchicalFacets, 1),\n            facetName = _state$hierarchicalFa[0].name;\n          var facetValues = results.getFacetValues(facetName, {});\n          var facetItems = facetValues && !Array.isArray(facetValues) && facetValues.data ? facetValues.data : [];\n          var items = transformItems(shiftItemsValues(prepareItems(facetItems)), {\n            results: results\n          });\n          return items;\n        }\n        var items = getItems();\n        if (!connectorState.createURL) {\n          connectorState.createURL = function (facetValue) {\n            return createURL(function (uiState) {\n              return _this.getWidgetUiState(uiState, {\n                searchParameters: getRefinedState(helper.state, facetValue),\n                helper: helper\n              });\n            });\n          };\n        }\n        if (!connectorState.refine) {\n          connectorState.refine = function (facetValue) {\n            helper.setState(getRefinedState(helper.state, facetValue)).search();\n          };\n        }\n        return {\n          canRefine: items.length > 0,\n          createURL: connectorState.createURL,\n          items: items,\n          refine: connectorState.refine,\n          widgetParams: widgetParams\n        };\n      },\n      getWidgetUiState: function getWidgetUiState(uiState, _ref3) {\n        var searchParameters = _ref3.searchParameters;\n        var path = searchParameters.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);\n        return removeEmptyRefinementsFromUiState(_objectSpread(_objectSpread({}, uiState), {}, {\n          hierarchicalMenu: _objectSpread(_objectSpread({}, uiState.hierarchicalMenu), {}, _defineProperty({}, hierarchicalFacetName, path))\n        }), hierarchicalFacetName);\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref4) {\n        var uiState = _ref4.uiState;\n        var values = uiState.hierarchicalMenu && uiState.hierarchicalMenu[hierarchicalFacetName];\n        if (searchParameters.isConjunctiveFacet(hierarchicalFacetName) || searchParameters.isDisjunctiveFacet(hierarchicalFacetName)) {\n          process.env.NODE_ENV === 'development' ? warning(false, \"HierarchicalMenu: Attribute \\\"\".concat(hierarchicalFacetName, \"\\\" is already used by another widget applying conjunctive or disjunctive faceting.\\nAs this is not supported, please make sure to remove this other widget or this HierarchicalMenu widget will not work at all.\")) : void 0;\n          return searchParameters;\n        }\n        if (searchParameters.isHierarchicalFacet(hierarchicalFacetName)) {\n          var facet = searchParameters.getHierarchicalFacetByName(hierarchicalFacetName);\n          process.env.NODE_ENV === 'development' ? warning(isEqual(facet.attributes, attributes) && facet.separator === separator && facet.rootPath === rootPath, 'Using Breadcrumb and HierarchicalMenu on the same facet with different options overrides the configuration of the HierarchicalMenu.') : void 0;\n        }\n        var withFacetConfiguration = searchParameters.removeHierarchicalFacet(hierarchicalFacetName).addHierarchicalFacet({\n          name: hierarchicalFacetName,\n          attributes: attributes,\n          separator: separator,\n          rootPath: rootPath\n        });\n        if (!values) {\n          return withFacetConfiguration.setQueryParameters({\n            hierarchicalFacetsRefinements: _objectSpread(_objectSpread({}, withFacetConfiguration.hierarchicalFacetsRefinements), {}, _defineProperty({}, hierarchicalFacetName, []))\n          });\n        }\n        return withFacetConfiguration.addHierarchicalFacetRefinement(hierarchicalFacetName, values.join(separator));\n      }\n    };\n  };\n};\nfunction prepareItems(data) {\n  return data.reduce(function (result, currentItem) {\n    if (currentItem.isRefined) {\n      result.push({\n        label: currentItem.name,\n        value: currentItem.escapedValue\n      });\n      if (Array.isArray(currentItem.data)) {\n        result = result.concat(prepareItems(currentItem.data));\n      }\n    }\n    return result;\n  }, []);\n}\nfunction shiftItemsValues(array) {\n  return array.map(function (x, idx) {\n    return {\n      label: x.label,\n      value: idx + 1 === array.length ? null : array[idx + 1].value\n    };\n  });\n}\nfunction removeEmptyRefinementsFromUiState(indexUiState, attribute) {\n  if (!indexUiState.hierarchicalMenu) {\n    return indexUiState;\n  }\n  if (!indexUiState.hierarchicalMenu[attribute] || !indexUiState.hierarchicalMenu[attribute].length) {\n    delete indexUiState.hierarchicalMenu[attribute];\n  }\n  if (Object.keys(indexUiState.hierarchicalMenu).length === 0) {\n    delete indexUiState.hierarchicalMenu;\n  }\n  return indexUiState;\n}\nexport default connectBreadcrumb;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}